# 10775풀이

- 풀이 도전 과정

## 1. bruteforce?

> 무작 위로 배치해보고 안되면 종료하는 backtracking방법
>> O(N!) ==> n이 10만인데, 절때 못풀지..

## 2. dp/greedy

> opt struct를 가지는가?
> dp 배열이 x이하에서 도킹 가는한 곳을 저장하는 배열이라고 하면
>> x에 도킹을 할 경우, 뒤에 x + 1 ~ 10**5까지 전부 -1을 해주면 가능하다

- 또한 greedy한 선택이 optimal 값으로 이어진다
- 여기서 greedy한 선택이란 도킹할 때, 최대한 높은 번호에 도킹하는 것을 말한다

### 하지만, 이는 O(N^2)의 시간복잡도를 가지고, N= 10^5인 경우에는 절때 못푼다

### 실제로 코드를 제출 했을때, 시간초과가 뜬다

- 그렇다면 현재 가능한 높은 번호에서 도킹하는 것을 찾는 알고리즘을 찾아야 하는데,
- O(N)보다 더 좋은 알고리즘을 찾아야한다

## union-find?

- https://velog.io/@chosj1526/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C
- 위의 글을 참고
- "따라서 거의 모든 크기의 N에 대해 4 이하의 값을 가진다고 합니다.
  즉, 현실적인 모든 입력에 대해 상수시간에 동작한다고 봐도 무관 하다고 합니다."

- 순차 탐색에 대한 시간을 줄여 줄 수 있는 자료구조가 되겠다

> - find: 도킹 가능한 자리를 찾아주는 함수
> - 도킹한 자리를 x라고 했을 때, greedy하게 x-1과 x를 union 해준다
>> greedy한 선택이 optimal을 보장해주기 때문..(왜 보장해주는지는 한번 이게 optimal이 아니라고 한번 가정을 해보고 증명을 해보십쇼)

- union-find 알고리즘인가? 이 정도는 생각해 봤지만, 구체적으로 구현에 실패하고, 다른 사람의 코드를 참고하였기 때문에, 백준에 제출을 하지는 않음..
