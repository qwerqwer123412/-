# 12757 풀이

- 문제 링크 : https://www.acmicpc.net/problem/12757

- 문제 설명을 꼭 읽어보시고.. 이해했다고 가정을 한 뒤 설명하겠습니다.

## n, m 은 10 ** 5

- 매번 m번의 처리가 필요한데, 이 처리에 가능한 시간복잡도는
-
    1. O(logn)
-
    2. O(k) ==> 이거 찾았으면 노벨상감인듯 ㄹㅇ

- 위 두개의 시간복잡도야 O(mlog(n))의 시간복잡도가 나와 시간 초과가 뜨지 않을 것이다.

### 필요한 작업: 가장 가까운 key값을 찾는 일이다.

1. BF => 모든 key들을 찾아서 가장 가까운 key를 찾기 => O(N)

> 총 O(M*N)의 시간복잡도 ==> 100% 시간초과가 뜰 것이다.

2. 그렇다면, O(log(N))의 시간복잡도를 가지는 연산 ==> 이진탐색!

- 이진 탐색을 통하여 나와 가장 가까운 key를 찾아보자

### 글로 간단한 설명.

1. mid와 나를 비교
2. mid - 나 > 0 : right줄이기
3. else: left 늘리기

- 추가로 나와 mid + 1, mid - 1이 나와 같은게 있는지 check해주면
- 중복여부 check가 쉬워진다

이를 바탕으로 적절하게
1, 2, 3연산을 수행 하면 된다

#### 좀 여러번 틀렸었는게,

- insert(i, data)를 해줘야 하는데, insert(i-1, data)을 해줌
- insert를 평소에 쓰지 않았더니 감이 안 잡힘
- 습관적으로 unit 테스트(?) 비슷하게 항상 check를 해서 오류를 잡을 수 있었다
- 파이참, 인텔리제이를 쓰면 그냥 구현하고 함수로 뽑아내주는 기능이 있으니 그걸 활용해도 좋을 듯

> 당연하지만 넣고 정렬하면 시간 초과가 뜬다
>> 그래서 가장 가까운 수 보다 크면 뒤에, 가까우면 앞에 넣는 방식으로 풀이