# 20442

## 1. 첫번째 풀이 아이디어
- 

### BruteForce로 풀 수 있을까?

- 아이디어: 힌트에 "어떤 문자열에서 몇 개의 문자를 지워서 부분 수열을 만들 수 있다"
- 그럼 몇개 뺄 것을 BF로 정해보자
- 시간복잡도? combination(300만, 1) + combination(300만, 2) + ..... + combination(300만, 300만)

> 그만 알아보도록 하자..

## 2번째 풀이

### Two Pointer

- BF로 풀다가 insight를 얻어서 떠오른 풀이
- 삽질하는 과정도 매우 중요한것 같다..

> k가 x개 있을 때의 경우를 따져보면 optimal 값을 찾을 수 있지 않을까?
> ex) KKRKK이 있을때, k가 4개 일 때, k가 2개일때..
>> kk r kk ==> 5 (k가 4개일때)
> > k r k ==> 3 (k가 3개일때)

- 설명이 부실한 것 같아서 다른 예시를 한번 보자

KKKRRKRKRK에서 k는 총 6개, ==> 6개인 경우, 4개인 경우, 2개인 경우

1) 6개인 경우: KKK RR K(R)K(R)K ==> result: 8
2) 4개인 경우: KK RR(K)(R)K(R)K ==> result : 6개
3) 2개인 경우: K (K)RR (K)(R)(K)(R) K ==> result: 4개
   따라서 answer은 8개

## 구현

1. a~b사이의 R의 개수를 매번 구하면 시간 초과가 뜰 것 같다 ==> 별도 배열에 저장

> (누적합 개념과 유사)
>> 이거 300만 개나 만들어야 해서 공간복잡도가 너무 안좋은거 아닌가..?
> 라는 생각이 들었지만 메모리가 1024MB 인걸 보고 그냥 바로 배열 만들었다 ㅎㅎ..

2. left, right ==> 최초 left, right좌표를 구해주는 과정
3. left, right 변수를 한칸씩 좁혀주기

- 자세한건 코드주석 확인해주시면 감사..